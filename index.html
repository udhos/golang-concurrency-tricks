<html>

<head>
<title>Golang Concurrency Tricks</title>
</head>

<body>
<h1>Golang Concurrency Tricks</h1>

<h2>Channel Hints</h2>

<ul>
  <li>
<p>C1. Do not close a channel from a receiver goroutine. Closing the channel from a receiver could make future sender goroutines to panic.</p>
  </li>
  <li>
    <p>C2. If a channel has multiple senders, do not close the channel from a sender goroutine. Closing the channel from a sender could make future sender goroutine to panic.</p>
    <p>Alternatively, coordinate senders so that only the last sender to leave closes the channel (for instance by using either atomic int or sync.WaitGroup)</p>
  </li>
  <li>
<p>C3. It is not required to close an unused channel. If no goroutine is left referencing the channel, it will be gargabe collected.</p>
<br>
<q>Note that it is only necessary to close a channel if the receiver is looking for a close.  Closing the channel is a control signal on the channel indicating that no more data follows.</q>
<br>
<a href="https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ">https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ</a>
  </li>
  <li>
<p>C4. Do not close a channel more than once because it would panic.</p>
  </li>
  <li>
<p>C5. Channels work better enclosed in a select.</p>
<br>
<q>If you are ever using a channel outside of a select in production code, you are probably doing it wrong.</q>
<br>
<a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ</a>
  </li>
  <li>
<p>C6. If you need bidirectional communication between two goroutines, consider using two unidirectional channels. Then any side will be able to use the close idiom to signal termination.</p>
  </li>
  <li>
<p>C7. Beware: one sender goroutine risks blocking indefinitely when writing on a channel if there is no goroutine left receiving from it.</p>
</li>
  <li>
<p>C8. When designing a goroutine which provides service throught channels, and at some point a running goroutine is no longer needed, consider exactly how it will finish. Otherwise, unused goroutines may leak idly servicing an unattended channel.</p>
</li>
  <li>
    <p>C9. Keep Dave Cheney's Four Channel Axioms in mind:</p>
    <ul>
      <li>A1. A send to a nil channel blocks forever.</li>
      <li>A2. A receive from a nil channel blocks forever.</li>
      <li>A3. A send to a closed channel panics.</li>
      <li>A4. A receive from a closed channel returns the zero value immediately.</li>
      </ul>
</li>
</ul>

<h2>Goroutine Hints</h2>

<ul>
  <li>
    <p>
      G1. Only one goroutine accessing a piece of data is good practice.
    </p>
    <q>
      In particular, consider structuring your program so that only one goroutine at a time is ever responsible for a particular piece of data.
    </q>
    <br>
    <a href="https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes">https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes</a>
  </li>
</ul>

<h2>See also:</h2>
<ul>
<li>
  <a href="http://www.slideshare.net/cloudflare/a-channel-compendium">http://www.slideshare.net/cloudflare/a-channel-compendium</a>
</li>
<li>
<a href="https://github.com/golang/go/wiki/LearnConcurrency">https://github.com/golang/go/wiki/LearnConcurrency</a>
</li>
<li>
  <a href="http://dave.cheney.net/2014/03/19/channel-axioms">http://dave.cheney.net/2014/03/19/channel-axioms</a>
</li>
</ul>

<hr>

<ul>
<li>Repository: git clone <a href="https://github.com/udhos/golang-concurrency-tricks.git">https://github.com/udhos/golang-concurrency-tricks.git</a></li>
<li>Web URL: <a href="http://udhos.github.io/golang-concurrency-tricks">http://udhos.github.io/golang-concurrency-tricks</a></li>
</ul>

</body>

</html>
