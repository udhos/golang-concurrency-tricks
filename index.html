<html>

<head>
<title>Golang Concurrency Tricks</title>
</head>

<body>
  <h1>Golang Concurrency Tricks</h1>

  <p>Golang concurrency model based on goroutines and channels is not free from sharp edges.</p>

  <p>This page intends both (1) to collect helpful guidelines for writing concurrent code in Go and (2) to bring up well known potential issues to attention.</p>

<h2>Channel Hints</h2>

<ul>
  <li>
<p>C1. Some channel operations cause runtime panic:</p>
    <ul>
      <li>P1. Closing the nil channel.</li>
      <li>P2. Closing a closed channel.</li>
      <li>P3. Sending on a closed channel.</li>
      </ul>
  </li>
  <li>
<p>C2. Do not close a channel from a receiver goroutine. Closing the channel from a receiver could make future sender goroutines to panic.</p>
  </li>
  <li>
    <p>C3. If a channel has multiple senders, do not close the channel from a sender goroutine. Closing the channel from a sender could make future sender goroutine to panic.</p>
    <p>Alternatively, coordinate senders so that only the last sender to leave closes the channel (for instance by using either atomic int or sync.WaitGroup)</p>
    <q>Last one sender to leave, turns off the lights, which can be controlled by a atomic int.</q>
    <br>
    <a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/oZFSD-oMAwAJ">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/oZFSD-oMAwAJ</a>
  </li>
  <li>
<p>C4. It is not required to close an unused channel. If no goroutine is left referencing the channel, it will be garbage collected.</p>
<q>Note that it is only necessary to close a channel if the receiver is looking for a close.  Closing the channel is a control signal on the channel indicating that no more data follows.</q>
<br>
<a href="https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ">https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ</a>
  </li>
  <li>
<p>C5. Channels work well when enclosed in a 'select'.</p>
<q>If you are ever using a channel outside of a select in production code, you are probably doing it wrong.</q>
<br>
<a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ</a>
  </li>
  <li>
<p>C6. If you need bidirectional communication between two goroutines, consider using two unidirectional channels. Thus both channel sides will be able to use the close idiom to signal termination.</p>
  </li>
  <li>
<p>C7. Beware: one sender goroutine risks blocking indefinitely when writing on a channel if there is no goroutine left receiving from it.</p>
</li>
  <li>
<p>C8. When designing a goroutine which provides service through channels, and at some point a running goroutine is no longer needed, consider exactly how it will finish. Otherwise, unused goroutines may leak idly servicing an unattended channel.</p>
</li>
  <li>
    <p>C9. Keep Dave Cheney's Four Channel Axioms in mind:</p>
    <ul>
      <li>A1. A send to a nil channel blocks forever.</li>
      <li>A2. A receive from a nil channel blocks forever. (<a href="https://groups.google.com/d/msg/golang-nuts/QltQ0nd9HvE/4TR-Bw1xbX8J">Here is why.</a>)</li>
      <li>A3. A send to a closed channel panics.</li>
      <li>A4. A receive from a closed channel returns the zero value immediately.</li>
      </ul>
</li>
<li>
<p>C10. 'select' never selects a blocking case.</p>
</li>
</ul>

<h2>Goroutine Hints</h2>

<ul>
  <li>
    <p>
      G1. Only one goroutine accessing a piece of data is good practice.
    </p>
    <q>In particular, consider structuring your program so that only one goroutine at a time is ever responsible for a particular piece of data.</q>
    <br>
    <a href="https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes">https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes</a>
  </li>
  <li>
    <p>
      G2. <a href="https://golang.org/pkg/runtime/#Goexit">runtime.Goexit()</a> terminates the goroutine that calls it.
    </p>
  </li>
</ul>

<h2>See also:</h2>
<ul>
<li>
  <a href="http://www.slideshare.net/cloudflare/a-channel-compendium">http://www.slideshare.net/cloudflare/a-channel-compendium</a>
</li>
<li>
<a href="https://github.com/golang/go/wiki/LearnConcurrency">https://github.com/golang/go/wiki/LearnConcurrency</a>
</li>
<li>
  <a href="http://dave.cheney.net/2014/03/19/channel-axioms">http://dave.cheney.net/2014/03/19/channel-axioms</a>
</li>
</ul>

<hr>

<ul>
<li>Repository: git clone <a href="https://github.com/udhos/golang-concurrency-tricks.git">https://github.com/udhos/golang-concurrency-tricks.git</a></li>
<li>Web URL: <a href="http://udhos.github.io/golang-concurrency-tricks">http://udhos.github.io/golang-concurrency-tricks</a></li>
</ul>

</body>

</html>
